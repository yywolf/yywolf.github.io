---
title: 可变与不可变对象修饰问题
date: 2018-08-24 22:33:56
tags: [iOS]
categories: iOS
---
### 不可变对象
#### 使用copy修饰不可变对象nameCopy，

```
@property (nonatomic, copy) NSString *nameCopy;
```

如果传进来的是不可变对象tempStr，nameCopy拷贝tempStr的地址并持有，当在其他地方修改tempStr的值时，其自动创建一个新的地址并赋值，并不会影响nameCopy的值；

```
NSString *tempStr = @"111";
NSLog(@"tempStr 1 =%p",tempStr);
//tempStr 1 = 0x10be59078

self.nameCopy = tempStr;
NSLog(@"nameCopy 1 =%p",self.nameCopy);
//nameCopy 1 = 0x10be59078

tempStr = @"222";
NSLog(@"tempStr 2 = %p",tempStr);
//tempStr 2 = 0x10be590d8

NSLog(@"nameCopy= %@   nameCopy 2 = %p",self.nameCopy,self.nameCopy);
// nameCopy = 111   nameCopy 2 = 0x10be59078
```

如果传进来的是可变对象tempMulStr，nameCopy并不拷贝tempMulStr的地址，自己创建一个地址空间来存储传入的值，当修改tempMulStr时，而这地址不一样，也无法影响到nameCopy的值。

```
NSMutableString *tempMulStr = [NSMutableString stringWithFormat:@"333"];
NSLog(@"tempMulStr 1 = %p",tempMulStr);
//tempMulStr 1 = 0x60000007d1c0

self.nameCopy = tempMulStr;
NSLog(@"nameCopy 1 = %p",self.nameCopy);
//nameCopy 1 = 0xa000000003333333

[tempMulStr appendString:@"444"];
NSLog(@"tempMulStr 2 = %p",tempMulStr);
//tempMulStr 2 = 0x60000007d1c0

NSLog(@"nameCopy= %@   nameCopy 2 = %p",self.nameCopy,self.nameCopy);
//nameCopy=333   nameCopy 2 = 0xa000000003333333
```

#### 使用strong修饰不可变对象

```
@property (nonatomic, strong) NSString *nameStrong;
```
如果传入的是不可变对象tempStr，nameStrong会拷贝他的地址空间并持有，再次修改tempStr，其会另外创建一个地址并赋值，并不会影响nameStrong的值；

```
NSString *tempStr = @"111";
NSLog(@"tempStr 1 = %p",tempStr);
//tempStr 1 = 0x10b08b078

self.nameStrong = tempStr;
NSLog(@"nameStrong 1 = %p",self.nameStrong);
//nameStrong 1 = 0x10b08b078

tempStr = @"222";
NSLog(@"tempStr 2 = %p",tempStr);
//tempStr 2 = 0x10b08b0d8

NSLog(@"nameStrong = %@   nameStrong 2 = %p",self.nameStrong,self.nameStrong);
// nameStrong = 111   nameStrong 2 = 0x10b08b078
```

如果传入的是可变对象tempMulStr，nameStrong会拷贝并一直持有tempMulStr的地址，在其他地方修改tempMulStr的值，nameStrong的值也一并会改变。

```
NSMutableString *tempMulStr = [NSMutableString stringWithFormat:@"333"];
NSLog(@"tempMulStr 1 = %p",tempMulStr);
//tempMulStr 1 = 0x600000078900

self.nameStrong = tempMulStr;
NSLog(@"nameStrong 1 = %p",self.nameStrong);
//nameStrong 1 = 0x600000078900
[tempMulStr appendString:@"444"];
NSLog(@"tempMulStr 2 = %p",tempMulStr);
//tempMulStr 2 = 0x600000078900

NSLog(@"nameStrong = %@   nameStrong 2 = %p",self.nameStrong,self.nameStrong);
//nameStrong = 333444   nameStrong 2 = 0x600000078900
```

这与我们的初衷(不可变对象)不符！

### 可变对象

#### 使用copy修饰可变对象nameMulCopy

```
@property (nonatomic, copy) NSMutableString *nameMulCopy;
```
使用copy修饰后，nameMulCopy就变成了不可变对象，但是我们声明的是可变对象，而且在使用可变对象的一些方法时，程序会crash。

```
NSString *tempStr = @"111";
NSLog(@"tempStr 1 = %p",tempStr);
// tempStr 1 = 0x10ceae078
//需要mutableCopy转化
self.nameMulCopy = [tempStr mutableCopy];
NSLog(@"nameMulCopy 1 = %p  tempStr = %p",self.nameMulCopy,tempStr);
//nameMulCopy 1 = 0xa000000003131313  tempStr = 0x10ceae078

tempStr = @"222";
NSLog(@"tempStr 2 = %p",tempStr);
//tempStr 2 = 0x10ceae0d8

//此行crash
//[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa000000003131313   
//未识别方法，因为copy后变成不可变对象了
[self.nameMulCopy appendString:@"333"];

NSLog(@"nameMulCopy = %@   nameMulCopy 2 = %p",self.nameMulCopy,self.nameMulCopy);
//nameMulCopy = 111   nameMulCopy 2 = 0xa000000003131313
    
    
NSMutableString *tempMulStr = [NSMutableString stringWithFormat:@"333"];
NSLog(@"tempMulStr 1 = %p",tempMulStr);
//tempMulStr 1 = 0x600000076d80

self.nameMulCopy = tempMulStr;
NSLog(@"nameMulCopy 1 = %p",self.nameMulCopy);
//nameMulCopy 1 = 0xa000000003333333

[tempMulStr appendString:@"444"];
NSLog(@"tempMulStr 2 = %p",tempMulStr);
//tempMulStr 2 = 0x600000076d80

NSLog(@"nameMulCopy = %@   nameMulCopy 2 = %p",self.nameMulCopy,self.nameMulCopy);
//nameMulCopy = 333   nameMulCopy 2 = 0xa000000003333333
```

#### 使用strong修饰可变对象nameMulStrong
如果传入的是不可变对象(需要mutableCopy转化)，nameMulStrong保存值到自己的地址，之后与tempStr在无关联。

```
NSString *tempStr = @"111";
NSLog(@"tempStr 1 = %p",tempStr);
//tempStr 1 = 0x10e89a078

self.nameMulStrong = [tempStr mutableCopy];
NSLog(@"nameMulStrong 1 = %p  tempStr = %p",self.nameMulStrong,tempStr);
//nameMulStrong 1 = 0x6000000723c0  tempStr = 0x10e89a078

tempStr = @"222";
NSLog(@"tempStr 2 = %p",tempStr);
// tempStr 2 = 0x10e89a0d8
    
NSLog(@"nameMulStrong = %@   nameMulStrong 2 = %p",self.nameMulStrong,self.nameMulStrong);
//nameMulStrong = 111   nameMulStrong 2 = 0x6000000723c0
```

如果传入的是可变对象，nameMulStrong会拷贝并一直持有传入对象的地址空间，当传入的对象值发生变化时，nameMulStrong也会发生变化。

```
NSMutableString *tempMulStr = [NSMutableString stringWithFormat:@"333"];
NSLog(@"tempMulStr 1 = %p",tempMulStr);
//tempMulStr 1 = 0x6080000730c0

self.nameMulStrong = tempMulStr;
NSLog(@"nameMulStrong 1 = %p",self.nameMulStrong);
// nameMulStrong 1 = 0x6080000730c0

[tempMulStr appendString:@"444"];
NSLog(@"tempMulStr 2 = %p",tempMulStr);
// tempMulStr 2 = 0x6080000730c0

NSLog(@"nameMulStrong = %@   nameMulStrong 2 = %p",self.nameMulStrong,self.nameMulStrong);
// nameMulStrong = 333444   nameMulStrong 2 = 0x6080000730c0
```
其他的可变与不可变对象与此同理。
### 结论:
	不可变对象应当用copy修饰；
	可变对象应当用strong修饰。